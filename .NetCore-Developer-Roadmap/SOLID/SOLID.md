# 物件導向- SOLID原則

SOLID五大原則共6條，就像四大天王都會有五位一樣，分別是:

1. S-單一職責原則 Single Responsibility Principle (SRP)
2. O-開放封閉原則 Open-Closed Principle (OCP)
3. L-里氏替換原則 Liskov Substitution Principle (LSP)
4. I-介面隔離原則 Interface Segregation Principle (ISP)
5. D-依賴反轉原則 Dependency Inversion Principle (DIP)
6. 迪米特法則/最小知識原則 Law of Demeter /Least Knowledge Principle (LKP)(L的地方有些教學會改此，兩者都很重要。)

### S－單一職責原則 Single Responsibility Principle(SRP)

- 「單一職責」原則顧名思義，就是一個類別應該只負責一個職責。

疑問點：怎麼區分什麼叫做職責? 

 ***＂就一個類別而言，應該只有一個引起它變化的原因、一個類別應該只對一個角色負責。＂***

簡單的一個例子，今天購物網站新增一筆訂單時。

```csharp
public class AddOrder(){
	//收到訂單
	訂單邏輯處理程序。
	//寫入訂單進入資料庫
	資料庫的連線，寫入資料庫作處理等程序。
	//取得客戶聯絡資訊
	取得資料庫客戶聯絡資訊
	//發送通知信件
	依據客戶資訊寄送通知信件至EMAIL，信件處理程序等等
}
```

像這樣的寫法看起來似乎沒有問題，但其實整個類別是很流水帳的，且當程式碼都寫出來寫完整是會發現此類別落落長，

且當要進行維護時會不好維護。

應改為如下:

```csharp
public class AddOrder(Order){
	OrderProcess(Order);
	CreateOrder(Order);
	OrderNotice(Order,Order.CustomerID);
}
public class OrderProcess(Order){
	//處理訂單的邏輯
}
public class CreateOrder(Order){
	//將訂單儲存於資料庫
}
public class OrderNotice(Order,CustomerID){
	//取的客戶資料，並且通知等等的程序
}
```

每個類別有自己的職責，互不干擾，這也包含封裝的概念，我只要知道你這類別需要給你什麼以及我會獲得什麼資訊，

而我呼叫類別作使用我不管裡面究竟實際執行了什麼，***把工作交給負責該職責的類別去做，自己只需要關注在自己正在處理的職責即可。***

- 當我們並未遵守單一職責原則時：

１．容易產生意外的重複。

２．無法界定邊界，無法確定這次修改影響到的範圍，也容易不確定這次修改對同一段做的所有事之間是否會相互影響。

３．修改時必須大量閱讀不相關的程式碼。

- 當我們終於選擇單一職責

１．提高了程式碼的重複使用程度，同時也降低了重複性，並且也提高了內聚。

２．能馬上掌握修改的目標和影響範圍，使得架構和類別更容易管理。也就是說，單一職責可以達到降低耦合的效果。

- 如何寫出漂亮，符合單一職責的程式法：**展示清楚你得意圖**。

---

### O－開放封閉原則 Open-Closed Principle (OCP)

- 軟體實體（類別、模組、函式等等）應該**對擴展開放，而對修改封閉。**

疑問點：什麼是擴展，什麼又是修改呢？

***＂擴展就是對東西額外加裝模組，修改則要將東西拆開在處理。＂***

***＂面對需求，對程式碼的改動是透過增加新程式碼進行的，而不是更改現有的程式碼＂***

可以透過＂**模組化** ＂來達到開放封閉原則。

就像是電腦在組裝時，主機板上會預留很多的插孔來因應未來可能會進行的擴充，在進行軟體開發、程式撰寫時也要留有好讓你擴展的地方，這些點就稱為擴充點。

在開發時，我們可以先區分主要邏輯和附加邏輯，舉例來說：可以如「查詢客戶」的主邏輯和各種不同「查詢客戶的條件」等等的組合。

因為如果不加以區分，我們就沒辦法把附加邏輯做成模組，也就找不到主要邏輯和附加邏輯之間的擴充點，如此一來就勢必要針對混成一坨的邏輯做修改和業務處理，接著就會落入我們在上一篇 [單一職責原則](https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle) 提過的各種悲慘下場：修改一個地方影響一狗票功能、修改前必須痛苦地閱讀大量不相關的程式碼…等等。

我們可以在主要邏輯和附加邏輯之間，加入抽象層來解耦合，當我們的類別不再堅持依賴某個物件，如此一來就夠用介面表達出需求，使得功能可以被任何符合需求的方式擴展。

使用外部注入來處理附加邏輯。除了不將附加邏輯寫在類別中，降低修改的機會以外，和介面的邏輯一致：你給什麼工具我就用什麼工具。

當我們的附加邏輯是從外部丟給類別，使得類別預先留好擴充點，並且能由外部決定擴充方式，要擴展也就相當容易了。

當我們在設置我們的擴充點（上個世紀稱作「放置鉤子」）時，有時會預測失敗，變成不必要的複雜性。也很容易走火入魔，就變成過度設計。因此，我們最終會等到足夠確信將會變化時，才進行重構的動作。

在無瑕的程式碼中，建議可以接受「被愚弄一次」，先假設不會變化，而當真的變化到來時，就將該變化相關的部份重構抽象起來，得了一次病，從此就免疫，還可以少走冤枉路。

---

### L－里氏替換原則 Liskov Substitution Principle (LSP)

- 子類別必須能夠替換父類別。
- 子類別替換父類別後，不需要改變，也不會發生任何錯誤或異常。

舉個簡單的例子...，當父類別為鳥，並設定鳥類會飛，這時候繼承此父類別的子類別是企鵝就很尷尬了...

用子類別實作出各式各樣不同的方法，藉此讓父類別的方法藉此達到延伸和多樣化的效果。

如此我們的物件彼此之間才能保持彈性，擁有可替換可擴充的特性。

進而達到 [開放封閉原則](https://igouist.github.io/post/2020/10/oo-11-open-closed-principle) 所要求的：

１．對修改封閉（不需要修改使用到父類別的地方），

２．對擴展開放（而是只需要用子類別進行擴充，就能完成變動）

這個擴展不該是天馬行空隨便亂擴的，必須要有原則。至少父類別能做到的事情，子類別也要能做到。

好的擴展方式，應該能滿足這些條件：

１．要求不應該比父類別多 

２．回饋不應該比父類別少

我們預期了這個函式或類別需要準備的輸入參數，也預期了應該要有的輸出結果。

如果某一天替換了子類別，卻不是這麼一回事，就會發生很多意料外的錯誤。

想要符合里氏替換原則時候，其實就可以試著遵守：

１．先驗條件（要求）不可以強化：父類別要求的是矩形，子類別就不能要求得更嚴，只准人家給正方形

２．後驗條件（回饋）不可以弱化：父類別產出的是正方形，子類別不能說沒關係啦，就給人家隨便一個矩形

３．不變條件（實作）必須保持不變：父類別是一個產生矩形的方法，子類別不能背骨，跑去產生圓形

- 真正的繼承應該是基於行為的：這個子類別能不能做到父類別期望的行為？這才是里氏替換原則的核心。
- 把觀看物件的角度集中在它的功能上，去試著了解父類別所期望的繼承方式，和使用者期望的預期結果。

---

### I－介面隔離原則 Interface Segregation Principle (ISP)

當介面規定了太多要求，而我們實作的子類別只需要其中一部份，或是有些要求根本無法達成，就會發生這個困境：放棄實作介面，或是用空實作和錯誤處理去欺騙介面。

- 不應該強迫用戶依賴它們未使用的方法。
    
    當我們必須強迫使用者去實作一些他們不需要的方法時，就代表了一個事實：我們的介面太「胖」了！裡面的某些要求可能是非必要的，以至於造成了實作上的冗餘。
    
- 應該最小化類別與類別之間的介面。
- 介面也要單一職責
    
    一個合理的介面設計是能夠符合單一職責原則的，反過來說，我們可以用單一職責原則來檢視我們的介面設計是否良好。
    
    這個介面的職責是否單一？這個介面的意圖是什麼？這個介面是否只對一個角色負責、只有一個原因改變？
    
    當我們的介面符合單一職責、足夠 [內聚](https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling) 的時候，我們自然就能夠說這個介面已經足夠精簡了。
    

用組合實現功能

我們的類別也要懂得斜槓，把想要的行為用職責的角度去思考，並且挑選並實作該類別需要的動作（介面），如此就可以讓介面不再臃腫，而是變得靈活。

舉例來說，今天企鵝不會飛，他的介面就不應該有飛行的選項，介面要拆分成游泳、跑步、飛行，各自依照功能去繼承上面提的介面來使用。

再舉例來說，再操作資料庫資料表時，不一定對每張表都有ＣＲＵＤ四個操作。

可以將拆開來看，基本上在寫一個網站對資料表都會有最基本的READ的使用，

此時可將此READ的介面先建立好下面GetData相關函式，

如果需要Ｃ／Ｕ時，可以建立Ｃ／Ｕ的介面而繼承READ的介面，接續需要Ｄ時，在建立Ｄ的介面繼承上述的介面，

在功能邏輯程式撰寫時，根據所需要的功能來使用其職責的介面，便減少產生出空繼承／空實作的情形。

功能不使用的功能就不要去繼承／實作。

---

### D－依賴反轉原則 Dependency Inversion Principle (DIP)

- 高階模組不應該依賴於低階模組。兩者都應該依賴抽象。

疑問點：什麼是依賴？　

所謂的依賴就是一種「受到某個東西影響、牽制」的狀態。當有「必須要藉由某個人事物來達到目的」的狀況時，就是依賴。

如果模組和另一個模組之間有關連，那這兩者之間就耦合。以此來看，依賴就是一種耦合的關係，那麼，依賴是健康還是不健康的耦合呢？

我們並不是用低階模組的功能直接拼湊出高階模組，讓高階模組直接依賴低階模組然後受到影響；而是把關注點放在需要的功能上，用介面隔開實作，解開他們彼此之間的耦合，介面就是模組之間的抽象層。

***並不是高階模組去依賴低階模組。而是高階模組提出它需要的功能，低階模組去實作出這些功能、達成高階模組的目標。***

***抽象不應該依賴細節；細節應該依賴抽象。***

### ⇒ 控制反轉 (Inversion of Control, IoC) &依賴注入 (Dependency Injection)

１．控制反轉 (Inversion of Control, IoC)

不再是由高階模組去建立並控制低階模組，而是我們讓一個控制反轉中心去建立低階模組，然後高階模組要使用的時候再把這個低階模組交給高階模組使用。

高階模組再也不需要關心如何建立，該建立哪個實體，只專注於使用功能，真正達到介面的精神。低階模組也只需要等待控制反轉中心分發，到了崗位就把份內事做好，專心在自己的職責身上即可。

２．依賴注入 (Dependency Injec tion)

２－１．建構式注入

建構式注入顧名思義就是從建立物件時的建構式進行注入。利用建構式的方式，從外部傳入該介面的實體來使用。

由於建構式注入比較符合封裝的「管控邊界」精神、能明確地讓維護者一看就知道哪些東西會被注入，因此絕大部分的時候都應該使用建構式注入，只有特殊情況可以使用方法注入和屬性注入。而到了 .net Core 的時代，預設的 DI 容器更是只提供建構式注入。所以理想的情況下，建構式注入應該要是最熟悉的注入方式。

２－２．方法注入

方法注入適用於「呼叫方法時需要注入不同的依賴對象」時。在呼叫方法的時候才把依賴對象一起丟進去。

２－３．屬性注入

從公開的屬性丟進去。「外部使用者要能夠隨時切換依賴對象」或是「類別已經有預設值了，但希望提供使用者可以覆寫掉預設值的彈性」時用到屬性注入。

---

### 迪米特法則/最小知識原則 Law of Demeter /Least Knowledge Principle (LKP)

只和直接的朋友溝通，不和陌生人說話。

當我們使用一個方法時，這個方法應該只認識：

- 該方法所屬的類別
- 該方法所接收的參數
- 該方法中建立的類別
- 該方法所屬的類別所依賴的對象

不應該使用其他類別的方法所回傳的類別的方法。

一個物件應該對其他物件應該只有最少的了解。

只依賴應該依賴的對象，只開放應該開放的方法。

***解除耦合***

建立更多的中間類別，或是更多的依賴關係。